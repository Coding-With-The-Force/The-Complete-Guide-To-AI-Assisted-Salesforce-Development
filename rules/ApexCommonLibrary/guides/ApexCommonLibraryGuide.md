### Apex Common Library Implementation Guide   

To properly implement the Apex Common Library when writing your Apex Classes you must think very hard and follow the rules outlined below:   

1. You first need to either find an existing Apex application class in the codebase or create an Apex class that represents an application factory. If you create a new Application class it needs to have the postfix "Application" in the class name. An exmaple of an application class you can reference is located here @rules/ApexCommonLibrary/examples/ExampleApplication.cls.    

2. For every single object you need to do a database operation on (insert, delete, update, etc), make sure you add that object to the application Apex class you made in step one's unit of work variable (An example of this is the "UOW" variable in located here @rules/ApexCommonLibrary/examples/ExampleApplication.cls). For all database operations you need to make in your Apex classes, you will use this unit of work variable in the application Apex class you created in step one of this markdown file. An example unit of work database update would be "fflib_ISObjectUnitOfWork unitOfWork = Application.UOW.newInstance(); unitOfWork.registerDirty(dataToBeUpdated); unitOfWork.commitWork();"   

3. For every Salesforce object that you create a SOQL query for in your Apex classes you need to create a Selector Apex class for it instead (or utilize an existing selector for that object if it exists in the codebase). Selector Apex class names should be postfixed with "_Selector". An example of a selector Apex class is located here @rules/ApexCommonLibrary/examples/Example_Selector.cls. Do not forget to add your new selector Apex class to your application Apex class that you made in step 1 of this markdown file. Also make sure that you always instantiate your selector Apex classes using the application class you created in step 1 of this markdown file. An example of a selector class instantiation would be "Case_Selector caseSelector = (Case_Selector)ExampleApplication.selector.newInstance(Case.SObjectType);" All selector classes should be declared with "inherited sharing".   

4. For every Salesforce object that you create an Apex Trigger for you need to create a Domain Apex class for it (or use an existing domain Apex class if it exists in the codebase), and call that Domain class from the trigger. The Domain Apex class should not contain ANY trigger context variables in it ever! When you name domain Apex classes they need to be a plural version of the Salesforce object you are creating the Apex class for. For example, if I was creating a Domain class for the Account object in Salesforce, I would name the domain class "Accounts. An example domain Apex class you can reference is located here @rules/ApexCommonLibrary/examples/Domains.cls. An example Apex trigger you can reference that shows you how to call your Domain apex class in it is located here @rules/ApexCommonLibrary/examples/ExampleTrigger.trigger. Do not forget to add your new domain Apex class to your application Apex class that you made in step 1. All domain classes should be declared with "inherited sharing".    

5. For every service Apex class you create, make sure you postfix the class name with "_Service". Additionally, make sure to add your service class to the application Apex class that you made in step 1. Also make sure that you always instantiate your service Apex classes using the application class you created in step 1 of this markdown file. An example of a service Apex class instantiation would be "Task_Service_Impl taskService = (Task_Service_Impl)ExampleApplication.service.newInstance(Task_Service_Impl.class);" All service classes should be declared "with sharing". Do not create an interface for a service Apex class unless you are explicitly told to do so. If you believe there is a need for an interface ask prior to create one and think hard and provide justification for your reasoning for an interface for your service Apex class.   

